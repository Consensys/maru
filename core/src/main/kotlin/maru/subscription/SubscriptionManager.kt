/*
 * Copyright Consensys Software Inc.
 *
 * This file is dual-licensed under either the MIT license or Apache License 2.0.
 * See the LICENSE-MIT and LICENSE-APACHE files in the repository root for details.
 *
 * SPDX-License-Identifier: MIT OR Apache-2.0
 */
package maru.subscription

import java.util.concurrent.CompletableFuture
import java.util.concurrent.CopyOnWriteArrayList
import kotlin.jvm.internal.CallableReference
import kotlin.reflect.jvm.ExperimentalReflectionOnLambdas
import org.apache.logging.log4j.LogManager
import org.apache.logging.log4j.Logger
import tech.pegasys.teku.infrastructure.async.SafeFuture

/**
 * Return the receiver object for a CallableReference.
 * It does not work for regular lambdas, as they do not have a receiver object.
 */
private fun findReceiverObjRef(subscriberMethodRef: Any): Any? {
  return if (subscriberMethodRef is CallableReference) {
    return subscriberMethodRef.boundReceiver
  } else {
    null
  }
}

@OptIn(ExperimentalReflectionOnLambdas::class)
private fun <T> getSubscriberId(subscriber: (T) -> Any?): String {
  val subscriberId =
    when {
      subscriber is kotlin.reflect.KFunction<*> && subscriber is CallableReference -> {
        // we need to make the reference unique, so will use receiver object hashcode
        val receiverObj = findReceiverObjRef(subscriber)
        "${subscriber.owner.toString().replace("class ", "")}.${subscriber.name}@${receiverObj.hashCode()}"
      }
      else -> {
        // this a Lambda function, so we will use stack trace to get it declaration point
        val className =
          subscriber.javaClass.name
            .split("$")
            .first()
        val lambdaDeclarationSite =
          Thread
            .currentThread()
            .stackTrace
            .find { it.className == className }
            .toString()
        "$lambdaDeclarationSite@${subscriber.hashCode()}"
      }
    }
  return subscriberId
}

interface ObservableUnsubscribable {
  fun removeSubscriber(subscriberId: String)

  /**
   * Removes a subscriber by reference. If reference is just a Function or Lambda will remove just one
   * if subscriber reference is an object, it will remove all subscribers that
   * have the same reference.
   * This is useful when you have multiple subscribers with the same reference
   */
  fun removeSubscriber(subscriberRef: Any)
}

interface SyncObservable<T> : ObservableUnsubscribable {
  fun addSyncSubscriber(
    subscriberId: String,
    syncHandler: (T) -> Any?,
  )

  fun addSyncSubscriber(syncHandler: (T) -> Any?): String {
    val subscriberId = getSubscriberId(syncHandler)
    addSyncSubscriber(subscriberId, syncHandler)
    return subscriberId
  }
}

interface AsyncObservable<T> : ObservableUnsubscribable {
  fun addAsyncSubscriber(
    subscriberId: String,
    asyncHandler: (T) -> CompletableFuture<*>,
  )

  /**
   * Adds a synchronous subscriber to the subscription manager.
   * The subscriber will be notified in a blocking manner when data is published.
   * The subscriberId is used to uniquely identify the subscriber for logging purposes when an error occurs.
   *
   * A subscriberId is generated by reflection automatically.
   * Note: caller cannot subscribe 2 lambdas in the same line of code
   * because it will generate the same subscriberId.
   */
  fun addAsyncSubscriber(asyncHandler: (T) -> CompletableFuture<*>): String {
    val subscriberId = getSubscriberId(asyncHandler)
    addAsyncSubscriber(subscriberId, asyncHandler)
    return subscriberId
  }
}

interface Observable<T> :
  SyncObservable<T>,
  AsyncObservable<T>

interface SubscriptionNotifier<T> {
  /**
   * It will notify all subscribers in a blocking manner, by order they were added.
   * If there sync and async subscribers, it will wait for async subscriber to complete
   * before notifying the next subscriber.
   */
  fun notifySubscribers(data: T)

  /**
   * It will notify all subscribers asynchronously, without blocking the current thread.
   * Subscriber notification order my not follow the order they were added.
   *
   * If the called does not wait on Future resolution,
   * the Order of notifications is not guaranteed, and may depend on the concrete implementation.
   *
   * Returned when all subscribers have been notified and resolved their futures.
   * If any subscriber fails, the future will be completed exceptionally.
   */
  fun notifySubscribersAsync(data: T): SafeFuture<Unit>
}

interface SubscriptionManager<T> :
  SubscriptionNotifier<T>,
  Observable<T>

/**
 * This is a simple implementation of SubscriptionManager that notifies all subscribers
 * in a fanout manner. Subscribers are notified in the order they are added.
 */
class InOrderFanoutSubscriptionManager<T>(
  val log: Logger = LogManager.getLogger(InOrderFanoutSubscriptionManager::class.java),
) : SubscriptionManager<T> {
  private data class SubscriberData<T>(
    val id: String,
    val syncHandler: ((T) -> Any?)? = null,
    val asyncHandler: ((T) -> CompletableFuture<*>)? = null,
  ) {
    init {
      require(syncHandler != null || asyncHandler != null) {
        "Either syncHandler or asyncHandler must be provided"
      }
      require(syncHandler == null || asyncHandler == null) {
        "Only one of syncHandler or asyncHandler can be provided"
      }
    }
  }

  private val subscribers: MutableList<SubscriberData<T>> = CopyOnWriteArrayList()

  private fun ensureUniqueSubscriber(
    subscriberId: String,
    handler: Any?,
  ) {
    subscribers
      .find { it.id == subscriberId || it.syncHandler == handler || it.asyncHandler == handler }
      ?.let { subscriber ->
        throw IllegalArgumentException("handler already subscribed with subscriberId=${subscriber.id}")
      }
  }

  override fun addSyncSubscriber(
    subscriberId: String,
    syncHandler: (T) -> Any?,
  ) {
    ensureUniqueSubscriber(subscriberId, syncHandler)
    subscribers.add(SubscriberData(subscriberId, syncHandler))
  }

  override fun addAsyncSubscriber(
    subscriberId: String,
    asyncHandler: (T) -> CompletableFuture<*>,
  ) {
    ensureUniqueSubscriber(subscriberId, asyncHandler)
    subscribers.add(SubscriberData(subscriberId, asyncHandler = asyncHandler))
  }

  override fun notifySubscribers(data: T) {
    logIfEmptySubscribers(data)
    subscribers.forEach { subscriber ->
      try {
        log.trace("Notifying subscriber={} with data={}", subscriber.id, data)
        subscriber.syncHandler?.invoke(data)
          ?: subscriber.asyncHandler?.invoke(data)?.join()
      } catch (th: Throwable) {
        logHandlingError(
          subscriberId = subscriber.id,
          data = data,
          th = th,
        )
      }
    }
  }

  override fun notifySubscribersAsync(data: T): SafeFuture<Unit> {
    logIfEmptySubscribers(data)
    val futures =
      subscribers.map { subscriber ->
        try {
          log.trace("Notifying subscriber={} with data={}", subscriber.id, data)
          subscriber.syncHandler
            ?.let { SafeFuture.completedFuture(it.invoke(data)) }
            ?: subscriber.asyncHandler?.invoke(data)!!
        } catch (th: Throwable) {
          logHandlingError(
            subscriberId = subscriber.id,
            data = data,
            th = th,
          )
          SafeFuture.failedFuture<Unit>(th)
        }
      }
    return SafeFuture.of(CompletableFuture.allOf(*futures.toTypedArray())).thenApply { }
  }

  override fun removeSubscriber(subscriberId: String) {
    val removed = subscribers.removeIf { it.id == subscriberId }
    if (!removed) {
      log.warn("No subscriber found with subscriberId={}", subscriberId)
    }
  }

  override fun removeSubscriber(subscriberRef: Any) {
    val removed =
      subscribers.removeIf {
        it.syncHandler == subscriberRef ||
          it.asyncHandler == subscriberRef ||
          // reference is a CallableReference, so we need to check the receiver object
          // and remove all if it's matches
          findReceiverObjRef(it.syncHandler ?: it.asyncHandler!!)
            ?.let { it == subscriberRef }
            ?: false
      }
    if (!removed) {
      log.warn("No subscriber found with handler={}", subscriberRef)
    }
  }

  private fun logIfEmptySubscribers(data: T) {
    if (subscribers.isEmpty()) {
      log.warn("empty subscribers list, following data wont be delivered: data={}", data)
    }
  }

  private fun logHandlingError(
    subscriberId: String,
    data: T,
    th: Throwable,
  ) {
    log.error(
      "errorMessage={} from subscriber={} handling data={}",
      th.message ?: "Unknown error",
      subscriberId,
      data,
      th,
    )
  }

  override fun toString(): String = "InOrderFanoutSubscriptionManager(subscribers=${subscribers.map { it.id }})"
}
